# C++ STL关联式容器详解

本章将介绍 STL 标准库中另一类容器，即关联式容器，包括 map、multimap、set 以及 multiset 这 4 种容器。

和序列式容器不同的是，关联式容器在存储元素时还会为每个元素在配备一个键，整体以键值对的方式存储到容器中。相比前者，关联式容器可以通过键值直接找到对应的元素，而无需遍历整个容器。另外，关联式容器在存储元素，默认会根据各元素键值的大小做升序排序。

相比其它类型容器，关联式容器查找、访问、插入和删除指定元素的效率更高。



本章内容：

1. [C++ STL关联式容器是什么？](http://c.biancheng.net/view/7166.html)

2. [C++ STL pair用法详解](http://c.biancheng.net/view/7169.html)

3. [C++ STL map容器详解](http://c.biancheng.net/view/7173.html)

4. [C++ STL map容器迭代器用法详解](http://c.biancheng.net/view/7174.html)

5. [C++ STL map获取键对应值的几种方法（超详细）](http://c.biancheng.net/view/7177.html)

6. [C++ STL map insert()插入数据的4种方式](http://c.biancheng.net/view/7181.html)

7. [C++ map容器operator[\]和insert()效率对比（深度剖析）](http://c.biancheng.net/view/vip_7719.html)

8. [C++ STL map emplace()和emplace_hint()方法详解](http://c.biancheng.net/view/7182.html)

9. [C++ map容器3种插入键值对的方法，谁的效率更高？](http://c.biancheng.net/view/vip_7720.html)

10. [C++ STL multimap容器用法完全攻略（超详细）](http://c.biancheng.net/view/7190.html)

11. [C++ STL set容器完全攻略（超级详细）](http://c.biancheng.net/view/7192.html)

12. [C++ STL set容器迭代器用法详解](http://c.biancheng.net/view/7194.html)

13. [C++ STL set insert()方法详解](http://c.biancheng.net/view/7196.html)

14. [C++ STL set emplace()和emplace_hint()方法详解](http://c.biancheng.net/view/7197.html)

15. [C++ STL set删除数据：erase()和clear()方法](http://c.biancheng.net/view/7198.html)

16. [C++ STL multiset容器详解](http://c.biancheng.net/view/7203.html)

17. [如何自定义C++ STL关联式容器的排序规则？](http://c.biancheng.net/view/vip_7721.html)

18. [如何修改关联式容器中键值对的键？](http://c.biancheng.net/view/vip_7722.html)



## 3.1 C++ STL关联式容器是什么？

在《[C++ STL容器](http://c.biancheng.net/view/6560.html)》一节中讲到，[C++](http://c.biancheng.net/cplus/) 容器大致分为 2 类，即序列式容器和关联式容器。其中，序列式容器（包括 array、vector、list、deque 和 forward_list）已经在前面章节中做了详细的介绍，从本节开始，将逐个对 C++ [STL](http://c.biancheng.net/stl/) 标准库中的所有关联式容器做详细的讲解。

提到 C++ STL 关联式容器，读者可能会以下一些疑问：

- 关联式容器是什么，具有哪些特点？
- 和序列式容器相比，关联式容器有什么不同？
- 关联式容器的种类有哪些？


别急，读完本文，这些疑问都会迎刃而解。

### C++ STL关联式容器是什么

通过学习所有的序列式容器不难发现，无论是哪种序列式容器，其存储的都是 C++ 基本数据类型（诸如 int、double、float、string 等）或使用结构体自定义类型的元素。例如，如下是一个存储 int 类型元素的 vector 容器：

```
std::vector<int> primes {2, 3, 5, 7, 11, 13, 17, 19};
```


关联式容器则大不一样，此类容器在存储元素值的同时，还会为各元素额外再配备一个值（又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。

> 弃用序列式容器，转而选用关联式容器存储元素，往往就是看中了关联式容器可以快速查找、读取或者删除所存储的元素，同时该类型容器插入元素的效率也比序列式容器高。

也就是说，使用关联式容器存储的元素，都是一个一个的“键值对”（ <key,value> ），这是和序列式容器最大的不同。除此之外，序列式容器中存储的元素默认都是未经过排序的，而使用关联式容器存储的元素，默认会根据各元素的键值的大小做升序排序。

注意，关联式容器所具备的这些特性，归咎于 STL 标准库在实现该类型容器时，底层选用了 「红黑树」这种[数据结构](http://c.biancheng.net/data_structure/)来组织和存储各个键值对。有关红黑树组织和存储数据的方式，我们已经在数据结构中做了详细的介绍，读者可猛击《[红黑树](http://c.biancheng.net/view/vip_3433.html)》一文做详细了解。

### C++ STL关联式容器种类

C++ STL 标准库提供了 4 种关联式容器，分别为 map、set、multimap、multiset，其各自的特点如表 1 所示。

| 关联式容器名称 | 特点                                                         |
| -------------- | ------------------------------------------------------------ |
| map            | 定义在 <map> 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序（调用 std::less<T>）。 |
| set            | 定义在 <set> 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序（调用 std::less<T>）。 |
| multimap       | 定义在 <map> 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复。 |
| multiset       | 定义在 <set> 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）。 |

> 除此之外，C++ 11 还新增了 4 种哈希容器，即 unordered_map、unordered_multimap 以及 unordered_set、unordered_multiset。严格来说，它们也属于关联式容器，但由于哈希容器底层采用的是哈希表，而不是红黑树，因此本教程将它们分开进行讲解（有关哈希容器，将放在后续章节做详细讲解）。


为了让读者直观地认识到关联式容器的特性，这里为 map 容器为例，编写了一个样例（如下所示）。对于该程序，读者只需体会关联式容器的特性即可，无需纠结 map 容器的具体用法。

```
#include <iostream>
#include <map> // 使用 map 容器，必须引入该头文件
#include <string>

using namespace std;
int main() {    
    // 创建一个空的 map 关联式容器，该容器中存储的键值对，其中键为 string 字符串，值也为 string 字符串类型    
    map<string, string> mymap;    
    
    // 向 mymap 容器中添加数据    
    mymap["http://c.biancheng.net/c/"] = "C语言教程";    
    mymap["http://c.biancheng.net/python/"] = "Python教程";    
    mymap["http://c.biancheng.net/java/"] = "Java教程";    
    
    // 使用 map 容器的迭代器，遍历 mymap 容器，并输出其中存储的各个键值对    
    for (map<string, string>::iterator it = mymap.begin(); it != mymap.end(); ++it) {        
        // 输出各个元素中的键和值        
        cout << it->first << " => " << it->second << '\n';    
    }
    
    return 0;
}
```

程序输出结果为：

```
http://c.biancheng.net/c/ => C语言教程
http://c.biancheng.net/java/ => Java教程
http://c.biancheng.net/python/ => Python教程
```


通过分析该程序的执行过程不难看出，mymap 关联式容器中的存储了以下 3 个键值对：

```
<"http://c.biancheng.net/c/", "C语言教程">
<"http://c.biancheng.net/python/", "Python教程">
<"http://c.biancheng.net/java/", "Java教程">
```



但需要注意的一点是，由于 map 容器在存储元素时，会根据各个元素键的大小自动调整元素的顺序（默认按照升序排序），因此该容器最终存储的元素顺序为：

```
<"http://c.biancheng.net/c/", "C语言教程">
<"http://c.biancheng.net/java/", "Java教程">
<"http://c.biancheng.net/python/", "Python教程">
```



> 有关 map 容器以及表 1 中其它关联式容器的具体用法，后续章节会做详细介绍。



## 3.2 C++ STL pair用法详解

我们知道，关联式容器存储的是“键值对”形式的数据，比如：

```
<"C语言教程", "http://c.biancheng.net/c/">
<"[Python](http://c.biancheng.net/python/)教程", "http://c.biancheng.net/python/">
<"[Java](http://c.biancheng.net/java/)教程", "http://c.biancheng.net/java/">
```



如上所示，每行都表示一个键值对，其中第一个元素作为键（key），第二个元素作为值（value）。

> 注意，基于各个关联式容器存储数据的特点，只有各个键值对中的键和值全部对应相等时，才能使用 set 和 multiset 关联式容器存储，否则就要选用 map 或者 multimap 关联式容器。

考虑到“键值对”并不是普通类型数据，[C++](http://c.biancheng.net/cplus/) [STL](http://c.biancheng.net/stl/) 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素`<first, second>`。通过其构成的元素格式不难看出，使用 pair 类模板来创建“键值对”形式的元素，再合适不过。

注意，pair 类模板定义在`<utility>`头文件中，所以在使用该类模板之前，需引入此头文件。另外值得一提的是，在 C++ 11 标准之前，pair 类模板中提供了以下 3 种构造函数：

```
#1) 默认构造函数，即创建空的 pair 对象
pair();

#2) 直接使用 2 个元素初始化成 pair 对象
pair(const first_type& a, const second_type& b);

#3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象
template<class U, class V> 
pair(const pair<U,V>& pr);
```

在 C++ 11 标准中，在引入[右值引用](http://c.biancheng.net/view/439.html)的基础上，pair 类模板中又增添了如下 2 个构造函数：

```
#4) 移动构造函数
template<class U, class V> 
pair(pair<U,V>&& pr);

#5) 使用右值引用参数，创建 pair 对象
template<class U, class V> 
pair(U&& a, V&& b);
```

> 除此之外，C++ 11 标准中 pair 类模板还新增加了如下一种构造函数：`pair (piecewise_construct_t pwc, tuple<Args1...> first_args, tuple<Args2...> second_args);`
>
> ，该构造 pair 类模板的方式很少用到，因此本节不再对其进行详细介绍，感兴趣的读者可自行查阅资料。

下面程序演示了以上几种创建 pair 对象的方法：

```
#include <iostream>
#include <utility>  
#include <string>   

using namespace std;

int main() {    
    // 调用构造函数 1，也就是默认构造函数    
    pair<string, double> pair1;    
    
    // 调用第 2 种构造函数    
    pair<string, string> pair2("STL教程","http://c.biancheng.net/stl/");      
    
    // 调用拷贝构造函数    
    pair <string, string> pair3(pair2);    
    
    // 调用移动构造函数    
    pair<string, string> pair4(make_pair("C++教程", "http://c.biancheng.net/cplus/"));    
    
    // 调用第 5 种构造函数    
    pair<string, string> pair5(string("Python教程"), string("http://c.biancheng.net/python/"));         
    
    cout << "pair1: " << pair1.first << " " << pair1.second << endl;    
    cout << "pair2: "<< pair2.first << " " << pair2.second << endl;    
    cout << "pair3: " << pair3.first << " " << pair3.second << endl;    
    cout << "pair4: " << pair4.first << " " << pair4.second << endl;    
    cout << "pair5: " << pair5.first << " " << pair5.second << endl;    
    
    return 0;
}
```

程序输出结果为：

```
pair1: 0
pair2: STL教程 http://c.biancheng.net/stl/
pair3: STL教程 http://c.biancheng.net/stl/
pair4: C++教程 http://c.biancheng.net/cplus/
pair5: Python教程 http://c.biancheng.net/python/
```



上面程序在创建 pair4 对象时，调用了 make_pair() 函数，它也是 <utility> 头文件提供的，其功能是生成一个 pair 对象。因此，当我们将 make_pair() 函数的返回值（是一个临时对象）作为参数传递给 pair() 构造函数时，其调用的是移动构造函数，而不是拷贝构造函数。

在上面程序的基础上，C++ 11 还允许我们手动为 pair1 对象赋值，比如：

```
pair1.first = "Java教程";
pair1.second = "http://c.biancheng.net/java/";

cout << "new pair1: " << pair1.first << " " << pair1.second << endl;
```

执行结果为：

```
new pair1: Java教程 http://c.biancheng.net/java/
```



同时，上面程序中 pair4 对象的创建过程，还可以写入如下形式，它们是完全等价的：

```
pair<string, string> pair4 = make_pair("C++教程", "http://c.biancheng.net/cplus/");
cout << "pair4: " << pair4.first << " " << pair4.second << endl;
```


`<utility>`头文件中除了提供创建 pair 对象的方法之外，还为 pair 对象重载了 <、<=、>、>=、==、!= 这 6 的运算符，其运算规则是：对于进行比较的 2 个 pair 对象，先比较 pair.first 元素的大小，如果相等则继续比较 pair.second 元素的大小。

> 注意，对于进行比较的 2 个 pair 对象，其对应的键和值的类型比较相同，否则将没有可比性，同时编译器提示没有相匹配的运算符，即找不到合适的重载运算符。

举个例子：

```
#include <iostream>
#include <utility>      
#include <string>

using namespace std;

int main() {    
    pair<string, int> pair1("STL教程", 20);    
    pair<string, int> pair2("C++教程", 20);    
    pair<string, int> pair3("C++教程", 30);    
    
    // pair1和pair2的key不同，value相同    
    if (pair1 != pair2) {        
        cout << "pair != pair2" << endl;    
    }
    
    // pair2和pair3的key相同，value不同    
    if (pair2 != pair3) {        
        cout << "pair2 != pair3" << endl;    
    }
    
    return 0;
}
```

程序执行结果为：

```
pair != pair2
pair2 != pair3
```


最后需要指出的是，pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同。例如：

```
#include <iostream>
#include <utility>
#include <string>

using namespace std;

int main() {    
    pair<string, int> pair1("pair", 10);                       
    pair<string, int> pair2("pair2", 20);    
    
    // 交换 pair1 和 pair2 的键值对    
    pair1.swap(pair2);    
    
    cout << "pair1: " << pair1.first << " " << pair1.second << endl;    
    cout << "pair2: " << pair2.first << " " << pair2.second << endl;    
    
    return 0;
}
```

程序执行结果为：

```
pair1: pair2 20
pair2: pair 10
```



## 3.3 C++ STL map容器详解

作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 [C++](http://c.biancheng.net/cplus/) 基本数据类型（int、double 等）、使用结构体或类自定义的类型。

> 通常情况下，map 容器中存储的各个键值对都选用 string 字符串作为键的类型。

与此同时，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序。默认情况下，map 容器选用`std::less<T>`排序规则（其中 T 表示键的数据类型），其会根据键的大小对所有键值对做升序排序。当然，根据实际情况的需要，我们可以手动指定 map 容器的排序规则，既可以选用 [STL](http://c.biancheng.net/stl/) 标准库中提供的其它排序规则（比如`std::greater<T>`），也可以自定义排序规则。

> 关于如何自定义 map 容器的排序规则，后续章节会做详细讲解。

另外需要注意的是，使用 map 容器存储的各个键值对，键的值既不能重复也不能被修改。换句话说，map 容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const 修饰，这意味着只要键值对被存储到 map 容器中，其键的值将不能再做任何修改。

> 前面提到，map 容器存储的都是 pair 类型的键值对元素，更确切的说，该容器存储的都是 pair<const K, T> 类型（其中 K 和 T 分别表示键和值的数据类型）的键值对元素。

map 容器定义在 <map> 头文件中，并位于 std 命名空间中。因此，如果想使用 map 容器，代码中应包含如下语句：

```
#include <map>using namespace std;
```

> 注意，第二行代码不是必需的，如果不用，则后续程序中在使用 map 容器时，需手动注明 std 命名空间（强烈建议初学者使用）。

map 容器的模板定义如下：

```
template < class Key,                                     // 指定键（key）的类型           class T,                                       // 指定值（value）的类型           class Compare = less<Key>,                     // 指定排序规则           class Alloc = allocator<pair<const Key,T> >    // 指定分配器对象的类型           > class map;
```

可以看到，map 容器模板有 4 个参数，其中后 2 个参数都设有默认值。大多数场景中，我们只需要设定前 2 个参数的值，有些场景可能会用到第 3 个参数，但最后一个参数几乎不会用到。

### 创建C++ map容器的几种方法

map 容器的模板类中包含多种构造函数，因此创建 map 容器的方式也有多种，下面就几种常用的创建 map 容器的方法，做一一讲解。

1) 通过调用 map 容器类的默认构造函数，可以创建出一个空的 map 容器，比如：

```
std::map<std::string, int> myMap;
```

> 如果程序中已经默认指定了 std 命令空间，这里可以省略 `std::`。

通过此方式创建出的 myMap 容器，初始状态下是空的，即没有存储任何键值对。鉴于空 map 容器可以根据需要随时添加新的键值对，因此创建空 map 容器是比较常用的。

2) 当然在创建 map 容器的同时，也可以进行初始化，比如：

```
std::map<std::string, int> myMap{ {"C语言教程", 10},{"STL教程", 20} };
```

由此，myMap 容器在初始状态下，就包含有 2 个键值对。

再次强调，map 容器中存储的键值对，其本质都是 pair 类模板创建的 pair 对象。因此，下面程序也可以创建出一模一样的 myMap 容器：

```
std::map<std::string, int> myMap{std::make_pair("C语言教程", 10), std::make_pair("STL教程", 20)};
```

3) 除此之外，在某些场景中，可以利用先前已创建好的 map 容器，再创建一个新的 map 容器。例如：

```
std::map<std::string, int> newMap(myMap);
```

由此，通过调用 map 容器的拷贝（复制）构造函数，即可成功创建一个和 myMap 完全一样的 newMap 容器。

C++ 11 标准中，还为 map 容器增添了移动构造函数。当有临时的 map 对象作为参数，传递给要初始化的 map 容器时，此时就会调用移动构造函数。举个例子：

```
# 创建一个会返回临时 map 对象的函数
std::map<std::string, int> disMap() {    
    std::map<std::string, int> tempMap{ {"C语言教程", 10}, {"STL教程", 20} };    
    return tempMap;
}

// 调用 map 类模板的移动构造函数创建 newMap 容器
std::map<std::string, int> newMap(disMap());
```

> 注意，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。

4) map 类模板还支持取已建 map 容器中指定区域内的键值对，创建并初始化新的 map 容器。例如：

```
std::map<std::string, int> myMap{ {"C语言教程", 10}, {"STL教程", 20} };
std::map<std::string, int> newMap(++myMap.begin(), myMap.end());
```

这里，通过调用 map 容器的双向迭代器，实现了在创建 newMap 容器的同时，将其初始化为包含一个 {"STL教程", 20} 键值对的容器。

> 有关 map 容器迭代器，后续章节会做详细讲解。



5) 当然，在以上几种创建 map 容器的基础上，我们都可以手动修改 map 容器的排序规则。默认情况下，map 容器调用 std::less<T> 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。

因此，如下 2 行创建 map 容器的方式，其实是等价的：

```
std::map<std::string, int> myMap{ {"C语言教程", 10}, {"STL教程", 20} };
std::map<std::string, int, std::less<std::string>> myMap{ {"C语言教程", 10}, {"STL教程", 20} };
```

以上 2 中创建方式生成的 myMap 容器，其内部键值对排列的顺序为：

```
<"C语言教程", 10>
<"STL教程", 20>
```


下面程序手动修改了 myMap 容器的排序规则，令其作降序排序：

```
std::map<std::string, int, std::greater<std::string>> myMap{ {"C语言教程", 10}, {"STL教程", 20} };
```

此时，myMap 容器内部键值对排列的顺序为：

```
<"STL教程", 20>
<"C语言教程", 10>
```



> 在某些特定场景中，我们还需要为 map 容器自定义排序规则，此部分知识后续将利用整整一节做重点讲解。

### C++ map容器包含的成员方法

表 1 列出了 map 容器提供的常用成员方法以及各自的功能。

| 成员方法         | 功能                                                         |
| ---------------- | ------------------------------------------------------------ |
| begin()          | 返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| end()            | 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| rbegin()         | 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
| rend()           | 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
| cbegin()         | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| cend()           | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| crbegin()        | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| crend()          | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| find(key)        | 在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| lower_bound(key) | 返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| upper_bound(key) | 返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| equal_range(key) | 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。 |
| empty()          | 若容器为空，则返回 true；否则 false。                        |
| size()           | 返回当前 map 容器中存有键值对的个数。                        |
| max_size()       | 返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 |
| operator[]       | map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。 |
| at(key)          | 找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。 |
| insert()         | 向 map 容器中插入键值对。                                    |
| erase()          | 删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。后续章节还会对该方法做重点讲解。 |
| swap()           | 交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。 |
| clear()          | 清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。   |
| emplace()        | 在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。 |
| emplace_hint()   | 在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。 |
| count(key)       | 在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。 |


下面的样例演示了表 1 中部分成员方法的用法：

```
#include <iostream>
#include <map>      
#include <string>       

using namespace std;
int main() {    
    // 创建空 map 容器，默认根据个键值对中键的值，对键值对做降序排序    
    std::map<std::string, std::string, std::greater<std::string>> myMap;    
    
    //调用 emplace() 方法，直接向 myMap 容器中指定位置构造新键值对    
    myMap.emplace("C语言教程", "http://c.biancheng.net/c/");    
    myMap.emplace("Python教程", "http://c.biancheng.net/python/");   
    myMap.emplace("STL教程", "http://c.biancheng.net/stl/");    
    
    // 输出当前 myMap 容器存储键值对的个数    
    cout << "myMap size==" << myMap.size() << endl;    
    
    // 判断当前 myMap 容器是否为空    
    if (!myMap.empty()) {        
        // 借助 myMap 容器迭代器，将该容器的键值对逐个输出        
        for (auto i = myMap.begin(); i != myMap.end(); ++i) {            
            cout << i->first << " " << i->second << endl;        
        }
     }
     
     return 0;
 }
```

程序执行结果为：

````
myMap size==3
STL教程 http://c.biancheng.net/stl/
Python教程 http://c.biancheng.net/python/
C语言教程 http://c.biancheng.net/c/
````



> 有关表 1 中其它成员函数的用法，后续章节会做详细详解。



## 3.4 C++ STL map容器迭代器用法详解

无论是前面学习的序列式容器，还是关联式容器，要想实现遍历操作，就必须要用到该类型容器的迭代器。当然，map 容器也不例外。

[C++](http://c.biancheng.net/cplus/) [STL](http://c.biancheng.net/stl/) 标准库为 map 容器配备的是双向迭代器（bidirectional iterator）。这意味着，map 容器迭代器只能进行 ++p、p++、--p、p--、*p 操作，并且迭代器之间只能使用 == 或者 != 运算符进行比较。

值得一提的是，相比序列式容器，map 容器提供了更多的成员方法（如表 1 所示），通过调用它们，我们可以轻松获取具有指定含义的迭代器。

| 成员方法         | 功能                                                         |
| ---------------- | ------------------------------------------------------------ |
| begin()          | 返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| end()            | 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| rbegin()         | 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
| rend()           | 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
| cbegin()         | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| cend()           | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| crbegin()        | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| crend()          | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| find(key)        | 在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| lower_bound(key) | 返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| upper_bound(key) | 返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| equal_range(key) | 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。 |


表 1 中多数的成员方法，诸如 begin()、end() 等，在学习序列式容器时已经多次使用过，它们的功能如图 2 所示。


![C++ STL map部分成员方法示意图](img/2-19112Q14QE40.gif)
<center>图 2 表 1 部分成员方法的功能示意图</center>

> 注意，图中 Ei 表示的是 pair 类对象，即键值对。对于 map 容器来说，每个键值对的键的值都必须保证是唯一的。

下面程序以 begin()/end() 组合为例，演示了如何遍历 map 容器：

```
#include <iostream>
#include <map>      
#include <string>       

using namespace std;
int main() {    
    // 创建并初始化 map 容器    
    std::map<std::string, std::string> myMap{ {"STL教程", "http://c.biancheng.net/stl/"}, {"C语言教程", "http://c.biancheng.net/c/"} };    
     
    // 调用 begin()/end() 组合，遍历 map 容器    
    for (auto iter = myMap.begin(); iter != myMap.end(); ++iter) {        
        cout << iter->first << " " << iter->second << endl;    
    }
    
    return 0;
}
```

程序执行结果为：

```
C语言教程 http://c.biancheng.net/c/
STL教程 http://c.biancheng.net/stl/
```



> 读者可自行尝试使用其他组合（如 cbegin()/cend()、 rbegin()/rend() 等）遍历 map 容器。


除此之外，map 类模板中还提供了 find() 成员方法，它能帮我们查找指定 key 值的键值对，如果成功找到，则返回一个指向该键值对的双向迭代器；反之，其功能和 end() 方法相同。

举个例子：

```
#include <iostream>
#include <map>      
#include <string>       

using namespace std;
int main() {    
    // 创建并初始化 map 容器    
    std::map<std::string, std::string>  myMap{ 
        {"STL教程", "http://c.biancheng.net/stl/"},                                             
        {"C语言教程","http://c.biancheng.net/c/"},                                             
        {"Java教程","http://c.biancheng.net/java/"} 
    };    
    
    
    // 查找键为 "Java教程" 的键值对    auto iter = myMap.find("Java教程");    
    // 从 iter 开始，遍历 map 容器    
    for (; iter != myMap.end(); ++iter) {        
        cout << iter->first << " " << iter->second << endl;    
    }
    
    return 0;
}
```

程序执行结果为：

```
Java教程 http://c.biancheng.net/java/
STL教程 http://c.biancheng.net/stl/
```


此程序中，创建并初始化的 myMap 容器，默认会根据各键值对中键的值，对各键值对做升序排序，其排序的结果为：

```
<"C语言教程","http://c.biancheng.net/c/">
<"Java教程","http://c.biancheng.net/java/">
<"STL教程","http://c.biancheng.net/stl/">
```



在此基础上，通过调用 find() 方法，我们可以得到一个指向键为 "Java教程" 的键值对的迭代器，由此当使用 [for 循环](http://c.biancheng.net/view/172.html)从该迭代器出开始遍历时，就只会遍历到最后 2 个键值对。

同时，map 类模板中还提供有 lower_bound(key) 和 upper_bound(key) 成员方法，它们的功能是类似的，唯一的区别在于：

- lower_bound(key) 返回的是指向第一个键不小于 key 的键值对的迭代器；
- upper_bound(key) 返回的是指向第一个键大于 key 的键值对的迭代器；


下面程序演示了它们的功能：

```
#include <iostream>
#include <map>      // pair#include <string>       // stringusing namespace std;int main() {    //创建并初始化 map 容器    std::map<std::string, std::string>myMap{ {"STL教程","http://c.biancheng.net/stl/"},                                             {"C语言教程","http://c.biancheng.net/c/"},                                             {"Java教程","http://c.biancheng.net/java/"} };    //找到第一个键的值不小于 "Java教程" 的键值对    auto iter = myMap.lower_bound("Java教程");    cout << "lower：" << iter->first << " " << iter->second << endl;       //找到第一个键的值大于 "Java教程" 的键值对    iter = myMap.upper_bound("Java教程");    cout <<"upper：" << iter->first << " " << iter->second << endl;    return 0;}
```

程序执行结果为：

lower：Java教程 http://c.biancheng.net/java/
upper：STL教程 http://c.biancheng.net/stl/

> lower_bound(key) 和 upper_bound(key) 更多用于 multimap 容器，在 map 容器中很少用到。


equal_range(key) 成员方法可以看做是 lower_bound(key) 和 upper_bound(key) 的结合体，该方法会返回一个 pair 对象，其中的 2 个元素都是迭代器类型，其中 pair.first 实际上就是 lower_bound(key) 的返回值，而 pair.second 则等同于 upper_bound(key) 的返回值。

显然，equal_range(key) 成员方法表示的一个范围，位于此范围中的键值对，其键的值都为 key。举个例子：

```
#include <iostream>#include <utility>  
#include <map>      
#include <string>       

using namespace std;
int main() {    
    //创建并初始化 map 容器    
    std::map<string, string> myMap{ 
        {"STL教程", "http://c.biancheng.net/stl/"},                                   
        {"C语言教程","http://c.biancheng.net/c/"},                                   
        {"Java教程","http://c.biancheng.net/java/"} 
    };
    
    // 创建一个 pair 对象，来接收 equal_range() 的返回值    
    pair <std::map<string, string>::iterator, std::map<string, string>::iterator> myPair = myMap.equal_range("C语言教程");    
    
    //通过遍历，输出 myPair 指定范围内的键值对    
    for (auto iter = myPair.first; iter != myPair.second; ++iter) {        
        cout << iter->first << " " << iter->second << endl;    
    }
    
    return 0;
}
```

程序执行结果为：

```
C语言教程 http://c.biancheng.net/c/
```

> 和 lower_bound(key)、upper_bound(key) 一样，该方法也更常用于 multimap 容器，因为 map 容器中各键值对的键的值都是唯一的，因此通过 map 容器调用此方法，其返回的范围内最多也只有 1 个键值对。





## 3.5 C++ STL map获取键对应值的几种方法（超详细）

我们知道，map 容器中存储的都是 pair 类型的键值对，但几乎在所有使用 map 容器的场景中，经常要做的不是找到指定的 pair 对象（键值对），而是从该容器中找到某个键对应的值。

> 注意，使用 map 容器存储的各个键值对，其键的值都是唯一的，因此指定键对应的值最多有 1 个。

庆幸的是，map 容器的类模板中提供了以下 2 种方法，可直接获取 map 容器指定键对应的值。

1) map 类模板中对`[ ]`运算符进行了重载，这意味着，类似于借助数组下标可以直接访问数组中元素，通过指定的键，我们可以轻松获取 map 容器中该键对应的值。

举个例子：

```
#include <iostream>
#include <map>      
#include <string>   

using namespace std;

int main() {    
    // 创建并初始化 map 容器    
    std::map<std::string, std::string> myMap{ 
        {"STL教程", "http://c.biancheng.net/stl/"},                                             
        {"C语言教程", "http://c.biancheng.net/c/"},
        {"Java教程", "http://c.biancheng.net/java/"} 
    };    
    
    string cValue = myMap["C语言教程"];    
    cout << cValue << endl;    
    
    return 0;
}
```

程序执行结果为：

```
http://c.biancheng.net/c/
```



可以看到，在第 11 行代码中，通过指定键的值为 "C语言教程"，借助重载的 [ ] 运算符，就可以在 myMap 容器中直接找到该键对应的值。

注意，只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ] 运算符才能成功获取该键对应的值；反之，若当前 map 容器中没有包含该指定键的键值对，则此时使用 [ ] 运算符将不再是访问容器中的元素，而变成了向该 map 容器中增添一个键值对。其中，该键值对的键用 [ ] 运算符中指定的键，其对应的值取决于 map 容器规定键值对中值的数据类型，如果是基本数据类型，则值为 0；如果是 string 类型，其值为 ""，即空字符串（即使用该类型的默认值作为键值对的值）。

举个例子：

```
#include <iostream>
#include <map>      
#include <string>   

using namespace std;
int main() {    
    // 创建空 map 容器    
    std::map<std::string, int> myMap;    
    int cValue = myMap["C语言教程"];    
    for (auto i = myMap.begin(); i != myMap.end(); ++i) {        
        cout << i->first << " "<< i->second << endl;    
    }    
    
    return 0;
}
```

程序执行结果为：

```
C语言教程 0
```



显然，对于空的 myMap 容器来说，其内部没有以 "C语言教程" 为键的键值对，这种情况下如果使用 [ ] 运算符获取该键对应的值，其功能就转变成了向该 myMap 容器中添加一个`<"C语言教程",0>`键值对（由于 myMap 容器规定各个键值对的值的类型为 int，该类型的默认值为 0）。

实际上，[ ] 运算符确实有“为 map 容器添加新键值对”的功能，但前提是要保证新添加键值对的键和当前 map 容器中已存储的键值对的键都不一样。例如：

```
#include <iostream>
#include <map>      
#include <string>   
using namespace std;

int main() {    
    // 创建空 map 容器    
    std::map<string, string> myMap;   
    myMap["STL教程"] = "http://c.biancheng.net/java/";    
    myMap["Python教程"] = "http://c.biancheng.net/python/";    
    myMap["STL教程"] = "http://c.biancheng.net/stl/";    
    
    for (auto i = myMap.begin(); i != myMap.end(); ++i) {        
        cout << i->first << " " << i->second << endl;    
    }    
    
    return 0;
}
```

程序执行结果为：

```
Python教程 http://c.biancheng.net/python/
STL教程 http://c.biancheng.net/stl/
```



注意，程序中第 9 行代码已经为 map 容器添加了一个以 "STL教程" 作为键的键值对，则第 11 行代码的作用就变成了修改该键对应的值，而不再是为 map 容器添加新键值对。

2) 除了借助 [ ] 运算符获取 map 容器中指定键对应的值，还可以使用 at() 成员方法。和前一种方法相比，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出 out_of_range 异常。

举个例子：

```
#include <iostream>
#include <map>      
#include <string>   

using namespace std;
int main() {    
    // 创建并初始化 map 容器    
    std::map<std::string, std::string> myMap{ 
        {"STL教程", "http://c.biancheng.net/stl/"},                                             
        {"C语言教程", "http://c.biancheng.net/c/"},                                             
        {"Java教程", "http://c.biancheng.net/java/"} 
    };
    
    cout << myMap.at("C语言教程") << endl;    
    // 下面一行代码会引发 out_of_range 异常    
    // cout << myMap.at("Python教程") << endl;    
    
    return 0;
}
```

程序执行结果为：

```
http://c.biancheng.net/c/
```



程序第 12 行代码处，通过 myMap 容器调用 at() 成员方法，可以成功找到键为 "C语言教程" 的键值对，并返回该键对应的值；而第 14 行代码，由于当前 myMap 容器中没有以 "Python教程" 为键的键值对，会导致 at() 成员方法查找失败，并抛出 out_of_range 异常。

除了可以直接获取指定键对应的值之外，还可以借助 find() 成员方法间接实现此目的。和以上 2 种方式不同的是，该方法返回的是一个迭代器，即如果查找成功，该迭代器指向查找到的键值对；反之，则指向 map 容器最后一个键值对之后的位置（和 end() 成功方法返回的迭代器一样）。

举个例子：

```
#include <iostream>
#include <map>      
#include <string>   

using namespace std;
int main() {    
    // 创建并初始化 map 容器    
    std::map<std::string, std::string> myMap{ 
        {"STL教程", "http://c.biancheng.net/stl/"},                                             
        {"C语言教程", "http://c.biancheng.net/c/"},                                            
        {"Java教程", "http://c.biancheng.net/java/"} 
    }; 
    
    map<std::string, std::string>::iterator myIter = myMap.find("C语言教程");    
    
    cout << myIter->first << " " << myIter->second << endl;    
    
    return 0;
}
```

程序执行结果为：

```
C语言教程 http://c.biancheng.net/c/
```



> 注意，此程序中如果 find() 查找失败，会导致第 13 行代码运行出错。因为当 find() 方法查找失败时，其返回的迭代器指向的是容器中最后一个键值对之后的位置，即不指向任何有意义的键值对，也就没有所谓的 first 和 second 成员了。


如果以上方法都不适用，我们还可以遍历整个 map 容器，找到包含指定键的键值对，进而获取该键对应的值。比如：

```
#include <iostream>
#include <map>      
#include <string>   

using namespace std;
int main() {    
    // 创建并初始化 map 容器    
    std::map<std::string, std::string> myMap{ 
        {"STL教程", "http://c.biancheng.net/stl/"},   
        {"C语言教程", "http://c.biancheng.net/c/"},
        {"Java教程", "http://c.biancheng.net/java/"} 
    };
    
    for (auto iter = myMap.begin(); iter != myMap.end(); ++iter) {        
        // 调用 string 类的 compare() 方法，找到一个键和指定字符串相同的键值对        
        if (!iter->first.compare("C语言教程")) {            
            cout << iter->first << " " << iter->second << endl;        
        }
        
    }
    
    return 0;
}
```

程序执行结果为：

```
C语言教程 http://c.biancheng.net/c/
```

> 本节所介绍的几种方法中，仅从“在 map 容器存储的键值对中，获取指定键对应的值”的角度出发，更推荐使用 at() 成员方法，因为该方法既简单又安全。



## 3.6 C++ STL map insert()插入数据的4种方式

前面讲过，[C++](http://c.biancheng.net/cplus/) [STL](http://c.biancheng.net/stl/) map 类模板中对`[ ]`运算符进行了重载，即根据使用场景的不同，借助`[ ]`运算符可以实现不同的操作。举个例子：

```
#include <iostream>
#include <map>  
#include <string> 

using namespace std;
int main() {    
    std:map<string, string> mymap{ 
        {"STL教程", "http://c.biancheng.net/java/"} 
    };    
    
    // 获取已存储键值对中，指定键对应的值    
    cout << mymap["STL教程"] << endl;    
    
    // 向 map 容器添加新键值对    
    mymap["Python教程"] = "http://c.biancheng.net/python/";    
    
    // 修改 map 容器已存储键值对中，指定键对应的值    
    mymap["STL教程"] = "http://c.biancheng.net/stl/";    
    
    for (auto iter = mymap.begin(); iter != mymap.end(); ++iter) {       
        cout << iter->first << " " << iter->second << endl;    
    }
    
    return 0;
}
```

程序执行结果为：

```
http://c.biancheng.net/java/
Python教程 http://c.biancheng.net/python/
STL教程 http://c.biancheng.net/stl/
```



可以看到，当操作对象为 map 容器中已存储的键值对时，则借助 [ ] 运算符，既可以获取指定键对应的值，还能对指定键对应的值进行修改；反之，若 map 容器内部没有存储以 [ ] 运算符内指定数据为键的键值对，则使用 [ ] 运算符会向当前 map 容器中添加一个新的键值对。

实际上，除了使用 [ ] 运算符实现向 map 容器中添加新键值对外，map 类模板中还提供有 insert() 成员方法，该方法专门用来向 map 容器中插入新的键值对。

注意，这里所谓的“插入”，指的是 insert() 方法可以将新的键值对插入到 map 容器中的指定位置，但这与 map 容器会自动对存储的键值对进行排序并不冲突。当使用 insert() 方法向 map 容器的指定位置插入新键值对时，其底层会先将新键值对插入到容器的指定位置，如果其破坏了 map 容器的有序性，该容器会对新键值对的位置进行调整。

自 C++ 11 标准后，insert() 成员方法的用法大致有以下 4 种。

1) 无需指定插入位置，直接将键值对添加到 map 容器中。insert() 方法的语法格式有以下 2 种：

```
//1、引用传递一个键值对
pair<iterator, bool> insert(const value_type& val);

//2、以右值引用的方式传递键值对
template <class P>
pair<iterator, bool> insert(P&& val);
```

其中，val 参数表示键值对变量，同时该方法会返回一个 pair 对象，其中 pair.first 表示一个迭代器，pair.second 为一个 bool 类型变量：

- 如果成功插入 val，则该迭代器指向新插入的 val，bool 值为 true；
- 如果插入 val 失败，则表明当前 map 容器中存有和 val 的键相同的键值对（用 p 表示），此时返回的迭代器指向 p，bool 值为 false。

以上 2 种语法格式的区别在于传递参数的方式不同，即无论是局部定义的键值对变量还是全局定义的键值对变量，都采用普通引用传递的方式；而对于临时的键值对变量，则以右值引用的方式传参。有关右值引用，可阅读《[C++右值引用](http://c.biancheng.net/view/439.html)》一文做详细了解。

举个例子：

```
#include <iostream>
#include <map> 

#include <string>
using namespace std;
int main() {    
    // 创建一个空 map 容器    
    std::map<string, string> mymap;       
    
    //创建一个真实存在的键值对变量    
    td::pair<string, string> STL = { "STL教程","http://c.biancheng.net/stl/" };      
    
    //创建一个接收 insert() 方法返回值的 pair 对象    
    std::pair<std::map<string, string>::iterator, bool> ret;       
    
    
    // 插入 STL，由于 STL 并不是临时变量，因此会以第一种方式传参    
    ret = mymap.insert(STL);    
    cout << "ret.iter = <{" << ret.first->first << ", " << ret.first->second << "}, " << ret.second << ">" << endl;    
    
    // 以右值引用的方式传递临时的键值对变量    
    ret = mymap.insert({ "C语言教程", "http://c.biancheng.net/c/" });    
    cout << "ret.iter = <{" << ret.first->first << ", " << ret.first->second << "}, " << ret.second << ">" << endl;    
    
    // 插入失败样例    
    ret = mymap.insert({ "STL教程", "http://c.biancheng.net/java/" });    
    cout << "ret.iter = <{" << ret.first->first << ", " << ret.first->second << "}, " << ret.second << ">" << endl;    
    
    return 0;
}
```

程序执行结果为：

```
ret.iter = <{STL教程, http://c.biancheng.net/stl/}, 1>
ret.iter = <{C语言教程, http://c.biancheng.net/c/}, 1>
ret.iter = <{STL教程, http://c.biancheng.net/stl/}, 0>
```

从执行结果中不难看出，程序中共执行了 3 次插入操作，其中成功了 2 次，失败了 1 次：

- 对于插入成功的 insert() 方法，其返回的 pair 对象中包含一个指向新插入键值对的迭代器和值为 1 的 bool 变量
- 对于插入失败的 insert() 方法，同样会返回一个 pair 对象，其中包含一个指向 map 容器中键为 "STL教程" 的键值对和值为 0 的 bool 变量。


另外，在程序中的第 21 行代码，还可以使用如下 2 种方式创建临时的键值对变量，它们是等价的：

```
// 调用 pair 类模板的构造函数
ret = mymap.insert(pair<string, string>{ "C语言教程", "http://c.biancheng.net/c/" });

// 调用 make_pair() 函数
ret = mymap.insert(make_pair("C语言教程", "http://c.biancheng.net/c/"));
```

2) 除此之外，insert() 方法还支持向 map 容器的指定位置插入新键值对，该方法的语法格式如下：

```
// 以普通引用的方式传递 val 参数
iterator insert(const_iterator position, const value_type& val);

// 以右值引用的方式传递 val 键值对参数
template <class P>
iterator insert(const_iterator position, P&& val);
```

其中 val 为要插入的键值对变量。注意，和第 1 种方式的语法格式不同，这里 insert() 方法返回的是迭代器，而不再是 pair 对象：

- 如果插入成功，insert() 方法会返回一个指向 map 容器中已插入键值对的迭代器；
- 如果插入失败，insert() 方法同样会返回一个迭代器，该迭代器指向 map 容器中和 val 具有相同键的那个键值对。


举个例子：

```
#include <iostream>
#include <map>  
#include <string> 

using namespace std;

int main() {    
    // 创建一个空 map 容器    
    std::map<string, string> mymap;       
    
    // 创建一个真实存在的键值对变量    
    std::pair<string, string> STL = { "STL教程", "http://c.biancheng.net/stl/" };    
    
    // 指定要插入的位置    
    std::map<string, string>::iterator it = mymap.begin();    
    
    // 向 it 位置以普通引用的方式插入 STL    
    auto iter1 = mymap.insert(it, STL);    
    cout << iter1->first << " " << iter1->second << endl;    
    
    // 向 it 位置以右值引用的方式插入临时键值对    
    auto iter2 = mymap.insert(it, std::pair<string, string>("C语言教程", "http://c.biancheng.net/c/"));    
    cout << iter2->first << " " << iter2->second << endl;    
    
    // 插入失败样例    
    auto iter3 = mymap.insert(it, std::pair<string, string>("STL教程", "http://c.biancheng.net/java/"));    
    cout << iter3->first << " " << iter3->second << endl;    
    
    return 0;
}
```

程序执行结果为：

```
STL教程 http://c.biancheng.net/stl/
C语言教程 http://c.biancheng.net/c/
STL教程 http://c.biancheng.net/stl/
```



再次强调，即便指定了新键值对的插入位置，map 容器仍会对存储的键值对进行排序。也可以说，决定新插入键值对位于 map 容器中位置的，不是 insert() 方法中传入的迭代器，而是新键值对中键的值。

3) insert() 方法还支持向当前 map 容器中插入其它 map 容器指定区域内的所有键值对，该方法的语法格式如下：

```
template <class InputIterator>
void insert(InputIterator first, InputIterator last);
```

其中 first 和 last 都是迭代器，它们的组合`<first,last>`可以表示某 map 容器中的指定区域。

举个例子：

```
#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {    
    // 创建并初始化 map 容器    
    std::map<std::string, std::string> mymap{ 
        {"STL教程", "http://c.biancheng.net/stl/"},                                                
        {"C语言教程", "http://c.biancheng.net/c/"},                                               
        {"Java教程", "http://c.biancheng.net/java/"} 
    };    
    
    // 创建一个空 map 容器    
    std::map<std::string, std::string> copymap;    
    
    //指定插入区域    
    std::map<string, string>::iterator first = ++mymap.begin();    
    std::map<string, string>::iterator last = mymap.end();    
    
    // 将<first, last>区域内的键值对插入到 copymap 中    
    copymap.insert(first, last);    
    
    / /遍历输出 copymap 容器中的键值对    
    for (auto iter = copymap.begin(); iter != copymap.end(); ++iter) {        
        cout << iter->first << " " << iter->second << endl;    
    }
    
    return 0;
}
```

程序执行结果为：

```
Java教程 http://c.biancheng.net/java/
STL教程 http://c.biancheng.net/stl/
```

此程序中，<first, last> 指定的区域是从 mumap 容器第 2 个键值对开始，之后所有的键值对，所以 copymap 容器中包含有 2 个键值对。

4) 除了以上一种格式外，insert() 方法还允许一次向 map 容器中插入多个键值对，其语法格式为：

```
void insert({val1, val2, ...});
```

其中，vali 都表示的是键值对变量。

举个例子：

```
#include <iostream>
#include <map>
#include <string>

using namespace std;
int main() {    
    // 创建空的 map 容器    
    std::map<std::string, std::string> mymap;    
    
    // 向 mymap 容器中添加 3 个键值对    
    mymap.insert({ 
        {"STL教程", "http://c.biancheng.net/stl/"},                   
        { "C语言教程", "http://c.biancheng.net/c/" },                   
        { "Java教程", "http://c.biancheng.net/java/" } 
    });    
    
    for (auto iter = mymap.begin(); iter != mymap.end(); ++iter) {       
        cout << iter->first << " " << iter->second << endl;    
    }
    
    
    return 0;
}
```

程序执行结果为：

```
C语言教程 http://c.biancheng.net/c/
Java教程 http://c.biancheng.net/java/
STL教程 http://c.biancheng.net/stl/
```

值得一提的是，除了 insert() 方法，map 类模板还提供 emplace() 和 emplace_hint() 方法，它们也可以完成向 map 容器中插入键值对的操作，且效率还会 insert() 方法高。关于这 2 个方法，会在下一节做详细介绍。



## 3.7 C++ map容器operator[]和insert()效率对比（深度剖析）

 ## 3.8 C++ STL map emplace()和emplace_hint()方法详解

学习 map insert() 方法时提到，[C++](http://c.biancheng.net/cplus/) [STL](http://c.biancheng.net/stl/) map 类模板中还提供了 emplace() 和 emplace_hint() 成员函数，也可以实现向 map 容器中插入新的键值对。本节就来讲解这 2 个成员方法的用法。

值得一提的是，实现相同的插入操作，无论是用 emplace() 还是 emplace_hont()，都比 insert() 方法的效率高（后续章节会详细讲解）。

和 insert() 方法相比，emplace() 和 emplace_hint() 方法的使用要简单很多，因为它们各自只有一种语法格式。其中，emplace() 方法的语法格式如下：

````=
template<class... Args>
pair<iterator, bool> emplace(Args&&... args);
````

参数 (Args&&... args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量：

- 当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true；
- 当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。


下面程序演示 emplace() 方法的具体用法：

```
#include <iostream>
#include <map>  
#include <string>

using namespace std;
int main() {    
    // 创建并初始化 map 容器    
    std::map<string, string> mymap;    
    
    // 插入键值对    
    pair<map<string, string>::iterator, bool> ret = mymap.emplace("STL教程", "http://c.biancheng.net/stl/");    
    cout << "1、ret.iter = <{" << ret.first->first << ", " << ret.first->second << "}, " << ret.second << ">" << endl;    
    
    // 插入新键值对    
    ret = mymap.emplace("C语言教程", "http://c.biancheng.net/c/");    
    cout << "2、ret.iter = <{" << ret.first->first << ", " << ret.first->second << "}, " << ret.second << ">" << endl;    
    
    // 失败插入的样例    
    ret = mymap.emplace("STL教程", "http://c.biancheng.net/java/");    
    cout << "3、ret.iter = <{" << ret.first->first << ", " << ret.first->second << "}, " << ret.second << ">" << endl;    
    
    return 0;
}
```

程序执行结果为：

```
1、ret.iter = <{STL教程, http://c.biancheng.net/stl/}, 1>
2、ret.iter = <{C语言教程, http://c.biancheng.net/c/}, 1>
3、ret.iter = <{STL教程, http://c.biancheng.net/stl/}, 0>
```



可以看到，程序中共执行了 3 次向 map 容器插入键值对的操作，其中前 2 次都成功了，第 3 次由于要插入的键值对的键和 map 容器中已存在的键值对的键相同，因此插入失败。

emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：

```
template<class... Args>
iterator emplace_hint(const_iterator position, Args&&... args);
```



显然和 emplace() 语法格式相比，有以下 2 点不同：

1. 该方法不仅要传入创建键值对所需要的数据，还需要传入一个迭代器作为第一个参数，指明要插入的位置（新键值对键会插入到该迭代器指向的键值对的前面）；
2. 该方法的返回值是一个迭代器，而不再是 pair 对象。当成功插入新键值对时，返回的迭代器指向新插入的键值对；反之，如果插入失败，则表明 map 容器中存有相同键的键值对，返回的迭代器就指向这个键值对。


下面程序演示 emplace_hint() 方法的用法：

```
#include <iostream>
#include <map>  
#include <string> 


using namespace std;
int main() {    
    // 创建并初始化 map 容器    
    std::map<string, string> mymap;    
    
    // 指定在 map 容器插入键值对    
    map<string, string>::iterator iter = mymap.emplace_hint(mymap.begin(), "STL教程", "http://c.biancheng.net/stl/");    
    cout << iter->first << " " << iter->second << endl;    
    
    iter = mymap.emplace_hint(mymap.begin(), "C语言教程", "http://c.biancheng.net/c/");    
    cout << iter->first << " " << iter->second << endl;    
    
    //插入失败样例    
    iter = mymap.emplace_hint(mymap.begin(), "STL教程", "http://c.biancheng.net/java/");    
    cout << iter->first << " " << iter->second << endl;    
    
    return 0;
}
```

程序执行结果为：

```
STL教程 http://c.biancheng.net/stl/
C语言教程 http://c.biancheng.net/c/
STL教程 http://c.biancheng.net/stl/
```



注意，和 insert() 方法一样，虽然 emplace_hint() 方法指定了插入键值对的位置，但 map 容器为了保持存储键值对的有序状态，可能会移动其位置。

那么，为什么 emplace() 和 emplace_hint() 方法的执行效率，比 insert() 高呢？下一节会做详细解释。



## 3.9 C++ map容器3种插入键值对的方法，谁的效率更高？



## 3.10 C++ STL multimap容器用法完全攻略（超详细）

在掌握 [C++](http://c.biancheng.net/cplus/) [STL](http://c.biancheng.net/stl/) map 容器的基础上，本节再讲一个和 map 相似的关联式容器，即 multimap 容器。

所谓“相似”，指的是 multimap 容器具有和 map 相同的特性，即 multimap 容器也用于存储 pair<const K, T> 类型的键值对（其中 K 表示键的类型，T 表示值的类型），其中各个键值对的键的值不能做修改；并且，该容器也会自行根据键的大小对存储的所有键值对做排序操作。和 map 容器的区别在于，multimap 容器中可以同时存储多（≥2）个键相同的键值对。

和 map 容器一样，实现 multimap 容器的类模板也定义在`<map>`头文件，并位于 std 命名空间中。因此，在使用 multimap 容器前，程序应包含如下代码：

```
#include <map>
using namespace std;
```

> 注意，第二行代码不是必需的，但若不用，则程序中在使用 multimap 容器时需手动注明 std 命名空间（强烈建议初学者使用）。

multimap 容器类模板的定义如下：

```
template<
    class Key,                                   // 指定键（key）的类型      
    class T,                                     // 指定值（value）的类型           
    class Compare = less<Key>,                   // 指定排序规则                
    class Alloc = allocator<pair<const Key, T>>  // 指定分配器对象的类型
>
class multimap;
```

可以看到，multimap 容器模板有 4 个参数，其中后 2 个参数都设有默认值。

> 大多数场景中，我们只需要设定前 2 个参数的值，有些场景可能会用到第 3 个参数，但最后一个参数几乎不会用到。

### 创建C++ multimap容器的方法

multimap 类模板内部提供有多个构造函数，总的来说，创建 multimap 容器的方式可归为以下 5 种。

1) 通过调用 multimap 类模板的默认构造函数，可以创建一个空的 multimap 容器：

```
std::multimap<std::string, std::string> mymultimap;
```

> 如果程序中已经默认指定了 std 命令空间，这里可以省略 std::。



2) 当然，在创建 multimap 容器的同时，还可以进行初始化操作。比如：

```
//创建并初始化 multimap 容器
multimap<string, string> mymultimap{ 
    {"C语言教程", "http://c.biancheng.net/c/"},                                    
    {"Python教程", "http://c.biancheng.net/python/"},
    {"STL教程", "http://c.biancheng.net/stl/"} 
};
```

注意，使用此方式初始化 multimap 容器时，其底层会先将每一个`{key, value}`创建成 pair 类型的键值对，然后再用已建好的各个键值对初始化 multimap 容器。

实际上，我们完全可以先手动创建好键值对，然后再用其初始化 multimap 容器。下面程序使用了 2 种方式创建 pair 类型键值对，再用其初始化 multimap 容器，它们是完全等价的：

```
// 借助 pair 类模板的构造函数来生成各个pair类型的键值对
multimap<string, string> mymultimap{    
    pair<string, string>{"C语言教程", "http://c.biancheng.net/c/"},    
    pair<string, string>{ "Python教程", "http://c.biancheng.net/python/"},   
    pair<string, string>{ "STL教程", "http://c.biancheng.net/stl/"}
};

// 调用 make_pair() 函数，生成键值对元素
// 创建并初始化 multimap 容器
multimap<string, string> mymultimap{   
    make_pair("C语言教程", "http://c.biancheng.net/c/"),    
    make_pair("Python教程", "http://c.biancheng.net/python/"),    
    make_pair("STL教程", "http://c.biancheng.net/stl/")
};
```



3) 除此之外，通过调用 multimap 类模板的拷贝（复制）构造函数，也可以初始化新的 multimap 容器。例如：

```
multimap<string, string> newmultimap(mymultimap);
```

由此，就成功创建一个和 mymultimap 完全一样的 newmultimap 容器。

在 C++ 11 标准中，还为 multimap 类增添了移动构造函数。即当有临时的 multimap 容器作为参数初始化新 multimap 容器时，其底层就会调用移动构造函数来实现初始化操作。举个例子：

```
// 创建一个会返回临时 multimap 对象的函数
multimap<string, string> dismultimap() {    
    multimap<string, string> tempmultimap{ 
        {"C语言教程", "http://c.biancheng.net/c/"},
        {"Python教程", "http://c.biancheng.net/python/"} 
    };    
    
    return tempmultimap;
}  

// 调用 multimap 类模板的移动构造函数创建 newMultimap 容器
multimap<string, string> newmultimap(dismultimap());
```

上面程序中，由于 dismultimap() 函数返回的 tempmultimap 容器是一个临时对象，因此在实现初始化 newmultimap 容器时，底层调用的是 multimap 容器的移动构造函数，而不再是拷贝构造函数。

> 注意，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。



4) multimap 类模板还支持从已有 multimap 容器中，选定某块区域内的所有键值对，用作初始化新 multimap 容器时使用。例如：

```
// 创建并初始化 multimap 容器
multimap<string, string> mymultimap{ 
    {"C语言教程", "http://c.biancheng.net/c/"},                                    
    {"Python教程", "http://c.biancheng.net/python/"}, 
    {"STL教程", "http://c.biancheng.net/stl/"} 
};

multimap<string, string> newmultimap(++mymultimap.begin(), mymultimap.end());
```

这里使用了 multimap 容器的迭代器，选取了 mymultimap 容器中的最后 2 个键值对，用于初始化 newmultimap 容器。

> multimap 容器迭代器，和 map 容器迭代器的用法完全相同，这里不再赘述。



5) 前面讲到，multimap 类模板共可以接收 4 个参数，其中第 3 个参数可用来修改 multimap 容器内部的排序规则。默认情况下，此参数的值为`std::less<T>`，这意味着以下 2 种创建 multimap 容器的方式是等价的：

```
multimap<char, int>  mymultimap{ {'a', 1}, {'b', 2} };
multimap<char, int, std::less<char>> mymultimap{ {'a', 1}, {'b', 2} };
```

mymultimap 容器中键值对的存储顺序为：

```
<a,1>
<b,2>
```


下面程序利用了 STL 模板库提供的`std::greater<T>`排序函数，实现令 multimap 容器对存储的键值对做降序排序：

```
multimap<char, int, std::greater<char>> mymultimap{ {'a', 1}, {'b',2 } };
```

其内部键值对的存储顺序为：

```
<b,2>
<a,1>
```



> 在某些特定场景中，我们还可以为 multimap 容器自定义排序规则，此部分知识后续将利用整整一节做重点讲解。

### C++ multimap容器包含的成员方法

表 1 列出了 multimap 类模板提供的常用成员方法及各自的功能。

| 成员方法         | 功能                                                         |
| ---------------- | ------------------------------------------------------------ |
| begin()          | 返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| end()            | 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| rbegin()         | 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
| rend()           | 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
| cbegin()         | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| cend()           | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| crbegin()        | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| crend()          | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| find(key)        | 在 multimap 容器中查找首个键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| lower_bound(key) | 返回一个指向当前 multimap 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| upper_bound(key) | 返回一个指向当前 multimap 容器中第一个大于 key 的键值对的迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| equal_range(key) | 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对。 |
| empty()          | 若容器为空，则返回 true；否则 false。                        |
| size()           | 返回当前 multimap 容器中存有键值对的个数。                   |
| max_size()       | 返回 multimap 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 |
| insert()         | 向 multimap 容器中插入键值对。                               |
| erase()          | 删除 multimap 容器指定位置、指定键（key）值或者指定区域内的键值对。 |
| swap()           | 交换 2 个 multimap 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。 |
| clear()          | 清空 multimap 容器中所有的键值对，使 multimap 容器的 size() 为 0。 |
| emplace()        | 在当前 multimap 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。 |
| emplace_hint()   | 在本质上和 emplace() 在 multimap 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。 |
| count(key)       | 在当前 multimap 容器中，查找键为 key 的键值对的个数并返回。  |


和 map 容器相比，multimap 未提供 at() 成员方法，也没有重载 [] 运算符。这意味着，map 容器中通过指定键获取指定指定键值对的方式，将不再适用于 multimap 容器。其实这很好理解，因为 multimap 容器中指定的键可能对应多个键值对，而不再是 1 个。

> 另外值的一提的是，由于 multimap 容器可存储多个具有相同键的键值对，因此表 1 中的 lower_bound()、upper_bound()、equal_range() 以及 count() 成员方法会经常用到。

下面例子演示了表 1 中部分成员方法的用法：

```
#include <iostream>
#include <map>  
using namespace std;   
int main() {    
    // 创建并初始化 multimap 容器    
    multimap<char, int> mymultimap{ {'a', 10}, {'b', 20}, {'b', 15}, {'c', 30} };    
    
    // 输出 mymultimap 容器存储键值对的数量    
    cout << mymultimap.size() << endl;    
    
    // 输出 mymultimap 容器中存储键为 'b' 的键值对的数量    
    cout << mymultimap.count('b') << endl;    
    
    for (auto iter = mymultimap.begin(); iter != mymultimap.end(); ++iter) {       
        cout << iter->first << " " << iter->second << endl;    
    }    
    
    
    return 0;
}
```

程序执行结果为：

```
4
2
a 10
b 20
b 15
c 30
```



> 注意，只要是 multimap 容器提供的成员方法，map 容器都提供，并且它们的用法是相同的。前面章节中已经对 map 容器提供的成员方法做了详细的讲解，因此这里不再对表 1 中其它的成员方法做详细的介绍。



## 3.11 C++ STL set容器完全攻略（超级详细）

前面章节讲解了 map 容器和 multimap 容器的用法，类似地，[C++](http://c.biancheng.net/cplus/) [STL](http://c.biancheng.net/stl/) 标准库中还提供有 set 和 multiset 这 2 个容器，它们也属于关联式容器。不过，本节先讲解 set 容器，后续章节再讲解 multiset 容器。

和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。

举个例子，如下有 2 组键值对数据：

```
{<'a', 1>,  <'b',  2>,  <'c',  3>}
{<'a',  'a'>,  <'b', 'b'>, <'c', 'c'>}
```

显然，第一组数据中各键值对的键和值不相等，而第二组中各键值对的键和值对应相等。对于 set 容器来说，只能存储第 2 组键值对，而无法存储第一组键值对。

基于 set 容器的这种特性，当使用 set 容器存储键值对时，只需要为其提供各键值对中的 value 值（也就是 key 的值）即可。仍以存储上面第 2 组键值对为例，只需要为 set 容器提供 {'a', 'b', 'c'} ，该容器即可成功将它们存储起来。

通过前面的学习我们知道，map、multimap 容器都会自行根据键的大小对存储的键值对进行排序，set 容器也会如此，只不过 set 容器中各键值对的键 key 和值 value 是相等的，根据 key 排序，也就等价为根据 value 排序。

另外，使用 set 容器存储的各个元素的值必须各不相同。更重要的是，从语法上讲 set 容器并没有强制对存储元素的类型做 const 修饰，即 set 容器中存储的元素的值是可以修改的。但是，C++ 标准为了防止用户修改容器中元素的值，对所有可能会实现此操作的行为做了限制，使得在正常情况下，用户是无法做到修改 set 容器中元素的值的。

> 对于初学者来说，切勿尝试直接修改 set 容器中已存储元素的值，这很有可能破坏 set 容器中元素的有序性，最正确的修改 set 容器中元素值的做法是：先删除该元素，然后再添加一个修改后的元素。

值得一提的是，set 容器定义于`<set>`头文件，并位于 std 命名空间中。因此如果想在程序中使用 set 容器，该程序代码应先包含如下语句：

```
#include <set>
using namespace std;
```

注意，第二行代码不是必需的，如果不用，则后续程序中在使用 set 容器时，需手动注明 std 命名空间（强烈建议初学者使用）。

set 容器的类模板定义如下：

```
template <
    class T,                        // 键 key 和值 value 的类型           
    class Compare = less<T>,        // 指定 set 容器内部的排序规则           
    class Alloc = allocator<T>      // 指定分配器对象的类型           
> 
class set;
```

注意，由于 set 容器存储的各个键值对，其键和值完全相同，也就意味着它们的类型相同，因此 set 容器类模板的定义中，仅有第 1 个参数用于设定存储数据的类型。

> 对于 set 类模板中的 3 个参数，后 2 个参数自带默认值，且几乎所有场景中只需使用前 2 个参数，第 3 个参数不会用到。

### 创建C++ set容器的几种方法

常见的创建 set 容器的方法，大致有以下 5 种。

1) 调用默认构造函数，创建空的 set 容器。比如：

```
std::set<std::string> myset;
```

> 如果程序中已经默认指定了 std 命令空间，这里可以省略 std::。

由此就创建好了一个 set 容器，该容器采用默认的`std::less<T>`规则，会对存储的 string 类型元素做升序排序。注意，由于 set 容器支持随时向内部添加新的元素，因此创建空 set 容器的方法是经常使用的。

2) 除此之外，set 类模板还支持在创建 set 容器的同时，对其进行初始化。例如：

```
std::set<std::string> myset{
    "http://c.biancheng.net/java/",                            
    "http://c.biancheng.net/stl/",                            
    http://c.biancheng.net/python/"
};
```

由此即创建好了包含 3 个 string 元素的 myset 容器。由于其采用默认的 std::less<T> 规则，因此其内部存储 string 元素的顺序如下所示：

```
"http://c.biancheng.net/java/"
"http://c.biancheng.net/python/"
"http://c.biancheng.net/stl/"
```



3) set 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 set 容器的同时，将已有 set 容器中存储的所有元素全部复制到新 set 容器中。

例如，在第 2 种方式创建的 myset 容器的基础上，执行如下代码：

```
std::set<std::string> copyset(myset);
//等同于//
std::set<std::string> copyset = myset
```

该行代码在创建 copyset 容器的基础上，还会将 myset 容器中存储的所有元素，全部复制给 copyset 容器一份。

另外，C++ 11 标准还为 set 类模板新增了移动构造函数，其功能是实现创建新 set 容器的同时，利用临时的 set 容器为其初始化。比如：

```
set<string> retSet() {    
    std::set<std::string> myset{ 
        "http://c.biancheng.net/java/",                            
        "http://c.biancheng.net/stl/",                            
        "http://c.biancheng.net/python/" 
    };    
    
    return myset;
}

std::set<std::string> copyset(retSet());
//或者//
std::set<std::string> copyset = retSet();
```

注意，由于 retSet() 函数的返回值是一个临时 set 容器，因此在初始化 copyset 容器时，其内部调用的是 set 类模板中的移动构造函数，而非拷贝构造函数。

> 显然，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。



4) 在第 3 种方式的基础上，set 类模板还支持取已有 set 容器中的部分元素，来初始化新 set 容器。例如：

```
std::set<std::string> myset{ 
    "http://c.biancheng.net/java/",                    
    "http://c.biancheng.net/stl/",                    
    "http://c.biancheng.net/python/" 
};

std::set<std::string> copyset(++myset.begin(), myset.end());
```

由此初始化的 copyset 容器，其内部仅存有如下 2 个 string 字符串：

```
"http://c.biancheng.net/python/"
"http://c.biancheng.net/stl/"
```



5) 以上几种方式创建的 set 容器，都采用了默认的`std::less<T>`规则。其实，借助 set 类模板定义中第 2 个参数，我们完全可以手动修改 set 容器中的排序规则。比如：

```
std::set<std::string, std::greater<string>> myset{    
    "http://c.biancheng.net/java/",    
    "http://c.biancheng.net/stl/",    
    "http://c.biancheng.net/python/"
};
```

通过选用 std::greater<string> 降序规则，myset 容器中元素的存储顺序为:

```
"http://c.biancheng.net/stl/"
"http://c.biancheng.net/python/"
"http://c.biancheng.net/java/"
```

### C++ STL set容器包含的成员方法

表 1 列出了 set 容器提供的常用成员方法以及各自的功能。

| 成员方法         | 功能                                                         |
| ---------------- | ------------------------------------------------------------ |
| begin()          | 返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| end()            | 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| rbegin()         | 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
| rend()           | 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
| cbegin()         | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
| cend()           | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
| crbegin()        | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
| crend()          | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
| find(val)        | 在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| lower_bound(val) | 返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| upper_bound(val) | 返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| equal_range(val) | 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。 |
| empty()          | 若容器为空，则返回 true；否则 false。                        |
| size()           | 返回当前 set 容器中存有元素的个数。                          |
| max_size()       | 返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。 |
| insert()         | 向 set 容器中插入元素。                                      |
| erase()          | 删除 set 容器中存储的元素。                                  |
| swap()           | 交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同。 |
| clear()          | 清空 set 容器中所有的元素，即令 set 容器的 size() 为 0。     |
| emplace()        | 在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。 |
| emplace_hint()   | 在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。 |
| count(val)       | 在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1。 |


下面程序演示了表 1 中部分成员函数的用法：

```
纯文本复制
#include <iostream>
#include <set>
#include <string>

using namespace std;

int main() {    
    // 创建空set容器    
    std::set<std::string> myset;    
    
    // 空set容器不存储任何元素    
    cout << "1、myset size = " << myset.size() << endl;    
    
    // 向myset容器中插入新元素    
    myset.insert("http://c.biancheng.net/java/");    
    myset.insert("http://c.biancheng.net/stl/");    
    yset.insert("http://c.biancheng.net/python/");    
    
    cout << "2、myset size = " << myset.size() << endl;    
    
    // 利用双向迭代器，遍历myset    
    for (auto iter = myset.begin(); iter != myset.end(); ++iter) {       
        cout << *iter << endl;    
    }
    
    return 0;
}
```

程序执行结果为：

```
1、myset size = 0
2、myset size = 3
http://c.biancheng.net/java/
http://c.biancheng.net/python/
http://c.biancheng.net/stl/
```



> 有关表 1 中其它成员方法的用法，后续章节会做详细讲解。



## 3.12 C++ STL set容器迭代器用法详解

和 map 容器不同，[C++](http://c.biancheng.net/cplus/) [STL](http://c.biancheng.net/stl/) 中的 set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。因此，要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器。

值得一提的是，C++ STL 标准库为 set 容器配置的迭代器类型为双向迭代器。这意味着，假设 p 为此类型的迭代器，则其只能进行 ++p、p++、--p、p--、*p 操作，并且 2 个双向迭代器之间做比较，也只能使用 == 或者 != 运算符。

在 set 容器类模板提供的所有成员函数中，返回迭代器的成员函数如表 1 所示。

| 成员方法         | 功能                                                         |
| ---------------- | ------------------------------------------------------------ |
| begin()          | 返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| end()            | 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| rbegin()         | 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
| rend()           | 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。通常和 rbegin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
| cbegin()         | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
| cend()           | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
| crbegin()        | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
| crend()          | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
| find(val)        | 在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| lower_bound(val) | 返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| upper_bound(val) | 返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| equal_range(val) | 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。 |

> 注意，以上成员函数返回的迭代器，指向的只是 set 容器中存储的元素，而不再是键值对。另外，以上成员方法返回的迭代器，无论是 const 类型还是非 const 类型，都不能用于修改 set 容器中的值。

图 2 演示了表 1 中除最后 4 个成员函数外，其它几个成员函数的具体功能。


![img](img/2-19112Q14QE40.gif)
<center>图 2 set容器迭代器功能示意图</center>

> 其中，Ei 表示 set 容器中存储的各个元素，它们的值各不相同。

下面程序以 begin()/end() 为例，演示了如何使用图 2 中相关迭代器遍历 set 容器：

```
#include <iostream>
#include <set>
#include <string>

using namespace std;

int main() {    
    // 创建并初始化set容器    
    std::set<std::string> myset{ 
        "http://c.biancheng.net/java/",                                 
        "http://c.biancheng.net/stl/",                                 
        "http://c.biancheng.net/python/"    
    };
    
    // 利用双向迭代器，遍历myset    
    for (auto iter = myset.begin(); iter != myset.end(); ++iter) {       
        cout << *iter << endl;    
    }
    
    return 0;
}
```

程序执行结果为：

```
http://c.biancheng.net/java/
http://c.biancheng.net/python/
http://c.biancheng.net/stl/
```

> 再次强调，正如程序第 15 行代码所示的那样，因为 iter 迭代器指向的是 set 容器存储的某个元素，而不是键值对，因此通过 *iter 可以直接获取该迭代器指向的元素的值。


除此之外，如果只想遍历 set 容器中指定区域内的部分数据，则可以借助 find()、lower_bound() 以及 upper_bound() 实现。通过调用它们，可以获取一个指向指定元素的迭代器。

需要特别指出的是，equal_range(val) 函数的返回值是一个 pair 类型数据，其包含 2 个迭代器，表示 set 容器中和指定参数 val 相等的元素所在的区域，但由于 set 容器中存储的元素各不相等，因此该函数返回的这 2 个迭代器所表示的范围中，最多只会包含 1 个元素。

举个例子：

```
#include <iostream>
#include <set>
#include <string>

using namespace std;
int main() {    
    // 创建并初始化set容器    
    std::set<std::string> myset{ 
        "http://c.biancheng.net/java/",                                 
        "http://c.biancheng.net/stl/",                                 
        "http://c.biancheng.net/python/"    
    };       
    
    set<string>::iterator iter = myset.find("http://c.biancheng.net/python/");    
    
    for (; iter != myset.end(); ++iter) {        
        cout << *iter << endl;    
    }    
    
    return 0;
}
```

程序执行结果为：

```
http://c.biancheng.net/python/
http://c.biancheng.net/stl/
```

> 值得一提的是，虽然 C++ STL 标准中，set 类模板中包含 lower_bound()、upper_bound()、equal_range() 这 3 个成员函数，但它们更适用于 multiset 容器，几乎不会用于操作 set 容器。



## 3.13 C++ STL set insert()方法详解

通过前面的学习，我们已经学会如何创建一个 set 容器。在此基础上，如果想向 set 容器中继续添加元素，可以借助 set 类模板提供的 insert() 方法。

为满足不同场景的需要，[C++](http://c.biancheng.net/cplus/) 11 标准的 set 类模板中提供了多种不同语法格式的 insert() 成员方法，它们各自的功能和用法如下所示。

1) 只要给定目标元素的值，insert() 方法即可将该元素添加到 set 容器中，其语法格式如下：

```
// 普通引用方式传参
pair<iterator, bool> insert(const value_type& val);

// 右值引用方式传参
pair<iterator, bool> insert(value_type&& val);
```

其中，val 表示要添加的新元素，该方法的返回值为 pair 类型。

> 以上 2 种格式的区别仅在于传递参数的方式不同，即第一种采用普通引用的方式传参，而第二种采用右值引用的方式传参。右值引用为 C++ 11 新添加的一种引用方式，可阅读《[C++ 右值引用](http://c.biancheng.net/view/439.html)》一文做详细了解。

可以看到，以上 2 种语法格式的 insert() 方法，返回的都是 pair 类型的值，其包含 2 个数据，一个迭代器和一个 bool 值：

- 当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true；
- 如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。


举个例子：

```
#include <iostream>
#include <set>
#include <string>

using namespace std;
int main() {    
    // 创建并初始化set容器    
    std::set<std::string> myset;    
    
    // 准备接受 insert() 的返回值    
    pair<set<string>::iterator, bool> retpair;    
    
    // 采用普通引用传值方式    
    string str = "http://c.biancheng.net/stl/";    
    retpair = myset.insert(str);    
    
    cout << "iter->" << *(retpair.first) << " " << "bool = " << retpair.second << endl;    
    
    // 采用右值引用传值方式    
    retpair = myset.insert("http://c.biancheng.net/python/");    
    cout << "iter->" << *(retpair.first) << " " << "bool = " << retpair.second << endl;    
    
    return 0;
}
```

程序执行结果为：

```
iter->http://c.biancheng.net/stl/ bool = 1
iter->http://c.biancheng.net/python/ bool = 1
```

通过观察输出结果不难看出，程序中两次借助 insert() 方法向 set 容器中添加元素，都成功了。

2) insert() 还可以指定将新元素插入到 set 容器中的具体位置，其语法格式如下：

```
// 以普通引用的方式传递 val 值
iterator insert(const_iterator position, const value_type& val);

// 以右值引用的方式传递 val 值
iterator insert(const_iterator position, value_type&& val);
```

以上 2 种语法格式中，insert() 函数的返回值为迭代器：

- 当向 set 容器添加元素成功时，该迭代器指向容器中新添加的元素；
- 当添加失败时，证明原 set 容器中已有相同的元素，该迭代器就指向 set 容器中相同的这个元素。


举个例子：

```
#include <iostream>
#include <set>
#include <string>

using namespace std;
int main() {    
    // 创建并初始化set容器    
    std::set<std::string> myset;    
    
    // 准备接受 insert() 的返回值    
    set<string>::iterator iter;    
    
    // 采用普通引用传值方式    
    string str = "http://c.biancheng.net/stl/";    
    iter = myset.insert(myset.begin(), str);   
    cout << "myset size =" << myset.size() << endl;    
    
    // 采用右值引用传值方式    
    iter = myset.insert(myset.end(), "http://c.biancheng.net/python/");    
    cout << "myset size =" << myset.size() << endl;    
    
    return 0;
}
```

程序执行结果为：

```
myset size =1
myset size =2
```

> 注意，使用 insert() 方法将目标元素插入到 set 容器指定位置后，如果该元素破坏了容器内部的有序状态，set 容器还会自行对新元素的位置做进一步调整。也就是说，insert() 方法中指定新元素插入的位置，并不一定就是该元素最终所处的位置。



3) insert() 方法支持向当前 set 容器中插入其它 set 容器指定区域内的所有元素，只要这 2 个 set 容器存储的元素类型相同即可。

insert() 方法的语法格式如下：

```
template <class InputIterator>
void insert(InputIterator first, InputIterator last);
```

其中 first 和 last 都是迭代器，它们的组合 [first,last) 可以表示另一 set 容器中的一块区域，该区域包括 first 迭代器指向的元素，但不包含 last 迭代器指向的元素。

举个例子：

```
#include <iostream>
#include <set>
#include <string>

using namespace std;
int main() {    
    // 创建并初始化set容器    
    std::set<std::string> myset{ 
        "http://c.biancheng.net/stl/",                                
        "http://c.biancheng.net/python/",                              
        "http://c.biancheng.net/java/" 
    };
    
    // 创建一个同类型的空 set 容器    
    std::set<std::string> otherset;    
    
    // 利用 myset 初始化 otherset   
    otherset.insert(++myset.begin(), myset.end());   
    
    // 输出 otherset 容器中的元素    
    for (auto iter = otherset.begin(); iter != otherset.end(); ++iter) {        
        cout << *iter << endl;    
    }
    
    return 0;
}
```

程序执行结果为：

```
http://c.biancheng.net/python/
http://c.biancheng.net/stl/
```



注意，程序第 15 行在初始化 otherset 容器时，选取的是 myset 容器中从第 2 个元素开始（包括此元素）直到容器末尾范围内的所有元素，所以程序输出结果中只有 2 个字符串。

4) 采用如下格式的 insert() 方法，可实现一次向 set 容器中添加多个元素：

```
void insert({E1, E2, ..., En});
```

其中，Ei 表示新添加的元素。

举个例子：

```
#include <iostream>
#include <set>
#include <string>

using namespace std;
int main() {    
    // 创建并初始化set容器    
    std::set<std::string> myset;    
    
    // 向 myset 中添加多个元素    
    myset.insert({ 
        "http://c.biancheng.net/stl/",        
        "http://c.biancheng.net/python/",        
        "http://c.biancheng.net/java/" 
    });
    
    for (auto iter = myset.begin(); iter != myset.end(); ++iter) {       
        cout << *iter << endl;   
    }
    
    return 0;
}
```

程序执行结果为：

```
http://c.biancheng.net/java/
http://c.biancheng.net/python/
http://c.biancheng.net/stl/
```

以上的讲解，即为 set 类模板中 insert() 成员方法的全部用法。指的一提的是，C++ 11 标准的 set 类模板中，还提供有另外 2 个成员方法，分别为 implace() 和 implace_hint() 方法，借助它们不但能实现向 set 容器添加新元素的功能，其实现效率也比 insert() 成员方法更高。

> 有关 set 类模板中 implace() 和 implace_hint() 方法的用法，后续章节会做详细介绍。



## 3.14 C++ STL set emplace()和emplace_hint()方法详

要知道，set 类模板提供的所有成员方法中，能实现向指定 set 容器中添加新元素的，只有 3 个成员方法，分别为 insert()、emplace() 和 emplace_hint()。其中 insert() 成员方法的用法已在前面章节做了详细的讲解，本节重点介绍剩下的这 2 个成员方法。

emplace() 和 emplace_hint() 是 [C++](http://c.biancheng.net/cplus/) 11 标准加入到 set 类模板中的，相比具有同样功能的 insert() 方法，完成同样的任务，emplace() 和 emplace_hint() 的效率会更高。

emplace() 方法的语法格式如下：

```
template <class... Args>
pair<iterator, bool> emplace(Args&&... args);
```



其中，参数 (Args&&... args) 指的是，只需要传入构建新元素所需的数据即可，该方法可以自行利用这些数据构建出要添加的元素。比如，若 set 容器中存储的元素类型为自定义的结构体或者类，则在使用 emplace() 方法向容器中添加新元素时，构造新结构体变量（或者类对象）需要多少个数据，就需要为该方法传入相应个数的数据。

另外，该方法的返回值类型为 pair 类型，其包含 2 个元素，一个迭代器和一个 bool 值：

- 当该方法将目标元素成功添加到 set 容器中时，其返回的迭代器指向新插入的元素，同时 bool 值为 true；
- 当添加失败时，则表明原 set 容器中已存在相同值的元素，此时返回的迭代器指向容器中具有相同键的这个元素，同时 bool 值为 false。


下面程序演示 emplace() 方法的具体用法：

```
#include <iostream>
#include <set>
#include <string>

using namespace std;

int main() {    
    // 创建并初始化 set 容器    
    std::set<string> myset;    
    
    // 向 myset 容器中添加元素    
    pair<set<string, string>::iterator, bool> ret = myset.emplace("http://c.biancheng.net/stl/");    
    cout << "myset size = " << myset.size() << endl;    
    cout << "ret.iter = <" << *(ret.first) << ", " << ret.second << ">" << endl;    
    
    return 0;
}
```

程序执行结果为：

```
myset size = 1
ret.iter = <http://c.biancheng.net/stl/, 1>
```

显然，从执行结果可以看出，通过调用 emplace() 方法，成功向空 myset 容器中添加了一个元素，并且该方法的返回值中就包含指向新添加元素的迭代器。

emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：

```
template <class... Args>
iterator emplace_hint (const_iterator position, Args&&... args);
```

和 emplace() 方法相比，有以下 2 点不同：

- 该方法需要额外传入一个迭代器，用来指明新元素添加到 set 容器的具体位置（新元素会添加到该迭代器指向元素的前面）；
- 返回值是一个迭代器，而不再是 pair 对象。当成功添加元素时，返回的迭代器指向新添加的元素；反之，如果添加失败，则迭代器就指向 set 容器和要添加元素的值相同的元素。


下面程序演示 emplace_hint() 方法的用法：

```
#include <iostream>
#include <set>
#include <string>

using namespace std;

int main() {    
    // 创建并初始化 set 容器    
    std::set<string> myset;    
    
    // 在 set 容器的指定位置添加键值对    
    set<string>::iterator iter = myset.emplace_hint(myset.begin(), "http://c.biancheng.net/stl/");    
    
    cout << "myset size = " << myset.size() << endl;    
    cout << *iter << endl;    
    return 0;
}
```

程序执行结果为：

```
myset size = 1
http://c.biancheng.net/stl/
```



注意，和 insert() 方法一样，虽然 emplace_hint() 方法中指定了添加新元素的位置，但 set 容器为了保持数据的有序状态，可能会移动其位置。

> 以上内容讲解了 emplace() 和 emplace_hint() 的用法，至于比 insert() 执行效率高的原因，可参照 map 容器 emplace() 和 emplace_hint() 比 insert() 效率高的原因，它们是完全一样的，这里不再赘述。



## 3.15 C++ STL set删除数据：erase()和clear()方法

如果想删除 set 容器存储的元素，可以选择用 erase() 或者 clear() 成员方法。

set 类模板中，erase() 方法有 3 种语法格式，分别如下：

```
//删除 set 容器中值为 val 的元素
size_type erase(const value_type& val);

// 删除 position 迭代器指向的元素
iterator erase(const_iterator position);
// 删除 [first,last) 区间内的所有元素
iterator erase(const_iterator first, const_iterator last);
```

其中，第 1 种格式的 erase() 方法，其返回值为一个整数，表示成功删除的元素个数；后 2 种格式的 erase() 方法，返回值都是迭代器，其指向的是 set 容器中删除元素之后的第一个元素。

> 注意，如果要删除的元素就是 set 容器最后一个元素，则 erase() 方法返回的迭代器就指向新 set 容器中最后一个元素之后的位置（等价于 end() 方法返回的迭代器）。

下面程序演示了以上 3 种 erase() 方法的用法：

```
#include <iostream>
#include <set>
#include <string>

using namespace std;
int main() {    
    // 创建并初始化 set 容器    
    std::set<int> myset{1, 2, 3, 4, 5};    
    cout << "myset size = " << myset.size() << endl;       
    
    // 1) 调用第一种格式的 erase() 方法    
    int num = myset.erase(2);      // 删除元素 2，myset={1, 3, 4, 5}    
    cout << "1、myset size = " << myset.size() << endl;    
    cout << "num = " << num << endl;    
    
    // 2) 调用第二种格式的 erase() 方法    
    set<int>::iterator iter = myset.erase(myset.begin()); // 删除元素 1，myset={3, 4, 5}    
    cout << "2、myset size = " << myset.size() << endl;    
    cout << "iter->" << *iter << endl;    
    
    // 3) 调用第三种格式的 erase() 方法    
    set<int>::iterator iter2 = myset.erase(myset.begin(), --myset.end()); // 删除元素 3, 4，myset={5}    
    cout << "3、myset size = " << myset.size() << endl;    
    cout << "iter2->" << *iter2 << endl;    
    
    return 0;
}
```

程序执行结果为：

```
myset size = 5
1、myset size = 4
num = 1
2、myset size = 3
iter->3
3、myset size = 1
iter2->5
```


如果需要删除 set 容器中存储的所有元素，可以使用 clear() 成员方法。该方法的语法格式如下：

```
void clear();
```

显然，该方法不需要传入任何参数，也没有任何返回值。

举个例子：

```
#include <iostream>
#include <set>
#include <string>

using namespace std;

int main() {    
    // 创建并初始化 set 容器    
    std::set<int> myset{1, 2, 3, 4, 5};   
    cout << "1、myset size = " << myset.size() << endl;    
    
    // 清空 myset 容器    
    myset.clear();    
    cout << "2、myset size = " << myset.size() << endl;    
    
    return 0;
}
```

程序执行结果为：

```
1、myset size = 5
2、myset size = 0
```



## 3.16 C++ STL multiset容器详解

前面章节中，对 set 容器做了详细的讲解。回忆一下，set 容器具有以下几个特性：

- 不再以键值对的方式存储数据，因为 set 容器专门用于存储键和值相等的键值对，因此该容器中真正存储的是各个键值对的值（value）；
- set 容器在存储数据时，会根据各元素值的大小对存储的元素进行排序（默认做升序排序）；
- 存储到 set 容器中的元素，虽然其类型没有明确用 const 修饰，但正常情况下它们的值是无法被修改的；
- set 容器存储的元素必须互不相等。


在此基础上，[C++](http://c.biancheng.net/cplus/) [STL](http://c.biancheng.net/stl/) 标准库中还提供有一个和 set 容器相似的关联式容器，即 multiset 容器。所谓“相似”，是指 multiset 容器遵循 set 容器的前 3 个特性，仅在第 4 条特性上有差异。和 set 容器不同的是，multiset 容器可以存储多个值相同的元素。

> 也就是说，multiset 容器和 set 容器唯一的差别在于，multiset 容器允许存储多个值相同的元素，而 set 容器中只能存储互不相同的元素。

和 set 类模板一样，multiset 类模板也定义在`<set>`头文件，并位于 std 命名空间中。这意味着，如果想在程序中使用 multiset 容器，该程序代码应包含如下语句：

```
#include <set>
using namespace std;
```

> 注意，第二行代码不是必需的，如果不用，则后续程序中在使用 multiset容器时，需手动注明 std 命名空间（强烈建议初学者使用）。

multiset 容器类模板的定义如下所示：

```
template < 
    class T,                        // 存储元素的类型           
    class Compare = less<T>,        // 指定容器内部的排序规则           
    class Alloc = allocator<T>      // 指定分配器对象的类型           
> 
class multiset;
```

显然，multiset 类模板有 3 个参数，其中后 2 个参数自带有默认值。值得一提的是，在实际使用中，我们最多只需要使用前 2 个参数即可，第 3 个参数不会用到。

### 创建C++ multiset容器的方法

创建 multiset 容器，无疑需要调用 multiset 类模板中的构造函数。值得一提的是，multiset 类模板提供的构造函数，和 set 类模板中提供创建 set 容器的构造函数，是完全相同的。这意味着，创建 set 容器的方式，也同样适用于创建 multiset 容器。

考虑到一些读者可能并未系统学习 set 容器，因此这里还是对 multiset 容器的创建做一下详细的介绍。

multiset 类模板中提供了 5 种构造函数，也就代表有 5 种创建 multiset 容器的方式，分别如下。

1) 调用默认构造函数，创建空的 multiset 容器。比如：

```
std::multiset<std::string> mymultiset;
```

> 如果程序中已经默认指定了 std 命令空间，这里可以省略 std::。

由此就创建好了一个 mymultiset 容器，该容器采用默认的`std::less<T>`规则，会对存储的 string 类型元素做升序排序。

> 注意，由于 multiset 容器支持随时向内部添加新的元素，因此创建空 multiset 容器的方法比较常用。


2)除此之外，multiset 类模板还支持在创建 multiset 容器的同时，对其进行初始化。例如：

```
std::multiset<std::string> mymultiset{ 
    "http://c.biancheng.net/java/",                                       
    "http://c.biancheng.net/stl/",                                       
    "http://c.biancheng.net/python/" 
};
```

由此即创建好了包含 3 个 string 元素的 mymultiset 容器。由于其采用默认的`std::less<T>`规则，因此其内部存储 string 元素的顺序如下所示：

```
"http://c.biancheng.net/java/"
"http://c.biancheng.net/python/"
"http://c.biancheng.net/stl/"
```



3) multiset 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 multiset 容器的同时，将已有 multiset 容器中存储的所有元素全部复制到新 multiset 容器中。

例如，在第 2 种方式创建的 mymultiset 容器的基础上，执行如下代码：

```
std::multiset<std::string> copymultiset(mymultiset);
//等同于//
std::multiset<std::string> copymultiset = mymultiset;
```

该行代码在创建 copymultiset 容器的基础上，还会将 mymultiset 容器中存储的所有元素，全部复制给 copymultiset 容器一份。

另外，C++ 11 标准还为 multiset 类模板新增了移动构造函数，其功能是实现创建新 multiset 容器的同时，利用临时的 multiset 容器为其初始化。比如：

```
multiset<string> retMultiset() {    
    std::multiset<std::string> tempmultiset{ 
        "http://c.biancheng.net/java/",                            
        "http://c.biancheng.net/stl/",                            
        "http://c.biancheng.net/python/" 
    };    
    
    return tempmultiset;
}

std::multiset<std::string> copymultiset(retMultiset());
//等同于//
std::multiset<std::string> copymultiset = retMultiset();
```

注意，由于 retMultiset() 函数的返回值是一个临时 multiset 容器，因此在初始化 copymultiset 容器时，其内部调用的是 multiset 类模板中的移动构造函数，而非拷贝构造函数。

> 显然，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。



4) 在第 3 种方式的基础上，multiset 类模板还支持取已有 multiset 容器中的部分元素，来初始化新 multiset 容器。例如：

```
std::multiset<std::string> mymultiset{ 
    "http://c.biancheng.net/java/",                                       
    "http://c.biancheng.net/stl/",                                       
    "http://c.biancheng.net/python/" 
};

std::set<std::string> copymultiset(++mymultiset.begin(), mymultiset.end());
```

以上初始化的 copyset 容器，其内部仅存有如下 2 个 string 字符串：

```
"http://c.biancheng.net/python/"
"http://c.biancheng.net/stl/"
```



5) 以上几种方式创建的 multiset 容器，都采用了默认的`std::less<T>`规则。其实，借助 multiset 类模板定义中的第 2 个参数，我们完全可以手动修改 multiset 容器中的排序规则。

下面样例中，使用了 STL 标准库提供的 std::greater<T> 排序方法，作为 multiset 容器内部的排序规则：

```
std::multiset<std::string, std::greater<string>> mymultiset{    
    "http://c.biancheng.net/java/",    
    "http://c.biancheng.net/stl/",   
    "http://c.biancheng.net/python/" 
};
```

通过选用`std::greater<string>`降序规则，mymultiset 容器中元素的存储顺序为:

```
"http://c.biancheng.net/stl/"
"http://c.biancheng.net/python/"
"http://c.biancheng.net/java/"
```

### C++ multiset容器提供的成员方法

multiset 容器提供的成员方法，和 set 容器提供的完全一样，如表 1 所示。

| 成员方法         | 功能                                                         |
| ---------------- | ------------------------------------------------------------ |
| begin()          | 返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| end()            | 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| rbegin()         | 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
| rend()           | 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
| cbegin()         | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
| cend()           | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
| crbegin()        | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
| crend()          | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
| find(val)        | 在 multiset 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| lower_bound(val) | 返回一个指向当前 multiset 容器中第一个大于或等于 val 的元素的双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| upper_bound(val) | 返回一个指向当前 multiset 容器中第一个大于 val 的元素的迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| equal_range(val) | 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含所有值为 val 的元素。 |
| empty()          | 若容器为空，则返回 true；否则 false。                        |
| size()           | 返回当前 multiset 容器中存有元素的个数。                     |
| max_size()       | 返回 multiset 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。 |
| insert()         | 向 multiset 容器中插入元素。                                 |
| erase()          | 删除 multiset 容器中存储的指定元素。                         |
| swap()           | 交换 2 个 multiset 容器中存储的所有元素。这意味着，操作的 2 个 multiset 容器的类型必须相同。 |
| clear()          | 清空 multiset 容器中所有的元素，即令 multiset 容器的 size() 为 0。 |
| emplace()        | 在当前 multiset 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。 |
| emplace_hint()   | 本质上和 emplace() 在 multiset 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。 |
| count(val)       | 在当前 multiset 容器中，查找值为 val 的元素的个数，并返回。  |

> 注意，虽然 multiset 容器和 set 容器拥有的成员方法完全相同，但由于 multiset 容器允许存储多个值相同的元素，因此诸如 count()、find()、lower_bound()、upper_bound()、equal_range()等方法，更常用于 multiset 容器。


下面程序演示了表 1 中部分成员函数的用法：

```
#include <iostream>
#include <set>
#include <string>

using namespace std;
int main() {    
    std::multiset<int> mymultiset{1, 2, 2, 2, 3, 4, 5};    
    cout << "multiset size = " << mymultiset.size() << endl;    
    cout << "multiset count(2) =" << mymultiset.count(2) << endl;    
    
    // 向容器中添加元素 8    
    mymultiset.insert(8);    
    
    // 删除容器中所有值为 2 的元素    
    int num = mymultiset.erase(2);    
    cout << "删除了 " << num << " 个元素 2" << endl;    
    
    // 输出容器中存储的所有元素   
    for (auto iter = mymultiset.begin(); iter != mymultiset.end(); ++iter) {       
        cout << *iter << " ";    
    }
    
    return 0;
}
```

程序执行结果为：

```
multiset size = 7
multiset count(2) =3
删除了 3 个元素 2
1 3 4 5 8
```



> 注意，表 1 中大多数成员方法的用法，和 set 容器中相应成员方法的用法是完全一样的，只是调用者不同。因此，如果读者想详细了解表 1 中某个成员方法的用法，可以阅读讲解 set 容器相同成员方法的文章。



## 3.17 如何自定义C++ STL关联式容器的排序规则？



## 3.18 如何修改关联式容器中键值对的键？

